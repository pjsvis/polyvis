<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PolyVis | Sigma Explorer</title>

  <link rel="stylesheet" href="/css/style.css" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>

  <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.js"></script>



  <script src="https://unpkg.com/sigma@2.4.0/build/sigma.min.js"></script>

  <script src="https://unpkg.com/graphology-library@0.8.0/dist/graphology-library.min.js"></script>

  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <!-- Alpine.js -->
  <script src="//unpkg.com/alpinejs" defer></script>

  <link rel="stylesheet" href="css/style.css" />
</head>

<body class="page-layout" x-data="sigmaApp()" :class="{ 'loaded': loaded }">
  <script src="/components/nav.js"></script>
  <div x-data="navigation" x-html="view"></div>

  <div class="container-box mx-auto w-full max-w-[1100px] p-4" style="margin-top: 2rem; margin-bottom: 4rem">
    <div class="mb-4 flex items-end justify-between">
      <h1 class="text-2xl font-bold uppercase">Neuro-Map (WebGL)</h1>
      <div id="status" class="text-right font-mono text-xs text-gray-500" x-html="status">
        Initializing...
      </div>
    </div>
    <div class="relative h-[600px] w-full border border-gray-300 bg-white">

      <!-- Graph Container (Sigma renders here) -->
      <div id="sigma-container" class="absolute inset-0 z-0" x-ref="sigmaContainer"></div>

      <!-- Analysis Controls -->
      <div
        style="position: absolute; top: 20px; left: 20px; display: flex; flex-wrap: wrap; gap: 10px; max-width: calc(100% - 200px); z-index: 10;">
        <div class="flex flex-wrap gap-2">
          <button class="btn-structural text-xs" :class="{ 'active': activeColorViz === 'louvain' }"
            @click="toggleColor('louvain')">
            <i data-lucide="users" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i>
            Louvain
          </button>
          <button class="btn-structural text-xs" :class="{ 'active': activeSizeViz === 'pagerank' }"
            @click="toggleSize('pagerank')">
            <i data-lucide="bar-chart-2"
              style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i>
            PageRank
          </button>
          <button class="btn-structural text-xs" :class="{ 'active': activeSizeViz === 'degree' }"
            @click="toggleSize('degree')">
            <i data-lucide="circle" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i>
            Degree
          </button>
          <button class="btn-structural text-xs" :class="{ 'active': activeColorViz === 'betweenness' }"
            @click="toggleColor('betweenness')">
            <i data-lucide="git-commit"
              style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i>
            Betweenness
          </button>
          <button class="btn-structural text-xs" :class="{ 'active': activeColorViz === 'components' }"
            @click="toggleColor('components')">
            <i data-lucide="share-2" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i>
            Components
          </button>
          <button class="btn-structural text-xs text-red-600" @click="resetStyles()">
            <i data-lucide="rotate-ccw"
              style="width: 12px; height: 12px; vertical-align: middle; margin-right: 4px;"></i>
            Reset Styles
          </button>
        </div>
        <button @click="toggleStats()" x-text="showStats ? 'Hide Stats' : 'Show Stats'" class="zoom-btn">Show
          Stats</button>

        <div style="width: 100%; height: 0; flex-basis: 100%;"></div> <!-- Line break -->

        <select x-model="layout" @change="runLayout($event.target.value)" class="zoom-btn" style="cursor: pointer;">
          <option value="forceatlas2">Layout: ForceAtlas2</option>
          <option value="circular">Layout: Circular</option>
          <option value="random">Layout: Random</option>
          <option value="noverlap">Layout: Noverlap (Refine)</option>
        </select>
      </div>

      <!-- Zoom Controls -->
      <div
        class="absolute bottom-4 right-4 flex flex-col gap-2 rounded-md border border-gray-300 bg-white/90 p-2 shadow-sm">
        <button class="btn-structural" @click="zoomIn()" title="Zoom In">
          <i data-lucide="zoom-in" style="width: 16px; height: 16px;"></i>
        </button>
        <button class="btn-structural" @click="zoomOut()" title="Zoom Out">
          <i data-lucide="zoom-out" style="width: 16px; height: 16px;"></i>
        </button>
        <button class="btn-structural" @click="resetZoom()" title="Reset Camera">
          <i data-lucide="maximize" style="width: 16px; height: 16px;"></i>
        </button>
      </div>

      <!-- Stats Panel -->
      <div x-show="showStats"
        style="position: absolute; bottom: 20px; left: 20px; background: white; border: 1px solid #ccc; border-radius: 4px; padding: 15px; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); font-family: monospace; font-size: 12px; z-index: 10; min-width: 200px;"
        x-transition>
        <div style="font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #ccc; padding-bottom: 5px;">Graph
          Statistics</div>
        <div><strong>Nodes:</strong> <span x-text="stats.nodes"></span></div>
        <div><strong>Edges:</strong> <span x-text="stats.edges"></span></div>
        <div><strong>Density:</strong> <span x-text="stats.density"></span></div>
        <div><strong>Avg Degree:</strong> <span x-text="stats.avgDegree"></span></div>
      </div>

    </div>
  </div>


  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('sigmaApp', () => ({
        status: 'Initializing...',
        graph: null,
        renderer: null,
        activeColorViz: null,
        activeSizeViz: null,
        layout: 'forceatlas2',
        showStats: false,
        stats: { nodes: 0, edges: 0, density: 0, avgDegree: 0 },
        loaded: false,

        init() {
          setTimeout(() => this.loaded = true, 50);
          this.initSqlJs();
          this.$nextTick(() => { if (window.lucide) window.lucide.createIcons(); });
        },

        initSqlJs() {
          initSqlJs({
            locateFile: (file) => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`,
          }).then((SQL) => {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", "/data/ctx.db", true);
            xhr.responseType = "arraybuffer";

            xhr.onload = (e) => {
              if (xhr.status !== 200) {
                this.status = `<span class="text-red-500">Error: ctx.db not found (Status ${xhr.status})</span>`;
                return;
              }
              const uInt8Array = new Uint8Array(xhr.response);
              const db = new SQL.Database(uInt8Array);
              this.loadGraph(db);
            };
            xhr.send();
          });
        },

        loadGraph(db) {
          // 1. Instantiate Graphology
          this.graph = new graphology.Graph();
          this.status = "Extracting Data...";

          // 2. Query Nodes
          try {
            const nodesStmt = db.prepare("SELECT * FROM nodes");
            while (nodesStmt.step()) {
              const row = nodesStmt.getAsObject();
              this.graph.addNode(row.id, {
                label: row.label,
                size: row.type === "Core Concept" ? 15 : 5,
                color: row.type === "Core Concept" ? "black" : "#999",
                originalSize: row.type === "Core Concept" ? 15 : 5,
                originalColor: row.type === "Core Concept" ? "black" : "#999",
                x: Math.random() * 100,
                y: Math.random() * 100,
              });
            }
          } catch (e) {
            console.error("Node Error", e);
          }

          // 3. Query Edges
          try {
            const edgesStmt = db.prepare("SELECT * FROM edges");
            while (edgesStmt.step()) {
              const row = edgesStmt.getAsObject();
              if (this.graph.hasNode(row.source) && this.graph.hasNode(row.target)) {
                if (!this.graph.hasEdge(row.source, row.target)) {
                  this.graph.addEdge(row.source, row.target, {
                    type: "arrow",
                    label: row.relation,
                    size: 2,
                    color: "#e5e5e5",
                  });
                }
              }
            }
          } catch (e) {
            console.error("Edge Error", e);
          }

          const nodeCount = this.graph.order;
          const edgeCount = this.graph.size;
          this.status = `Graph Loaded: ${nodeCount} Nodes, ${edgeCount} Edges. Running Physics...`;

          // 4. Run Layout (ForceAtlas2)
          this.runLayout('forceatlas2');

          // 5. Render with Sigma
          const container = this.$refs.sigmaContainer;
          container.innerHTML = ""; // Clear previous

          this.renderer = new Sigma(this.graph, container, {
            renderEdgeLabels: true,
          });

          // Disable mouse wheel zoom
          try {
            if (this.renderer.getMouseCaptor()) {
              this.renderer.getMouseCaptor().isMouseWheelEnabled = false;
            }
          } catch (e) { }

          container.addEventListener("wheel", (e) => e.stopPropagation(), true);

          this.status = "Interactive Mode Active. Buttons to Zoom, Drag to Move.";
        },

        zoomIn() {
          if (!this.renderer) return;
          const camera = this.renderer.getCamera();
          camera.animate({ ratio: camera.ratio / 1.5 });
        },

        zoomOut() {
          if (!this.renderer) return;
          const camera = this.renderer.getCamera();
          camera.animate({ ratio: camera.ratio * 1.5 });
        },

        zoomReset() {
          if (!this.renderer) return;
          this.renderer.getCamera().animatedReset();
        },

        resetColors() {
          this.graph.forEachNode((node, attributes) => {
            if (attributes.originalColor) this.graph.setNodeAttribute(node, "color", attributes.originalColor);
          });
        },

        resetSizes() {
          this.graph.forEachNode((node, attributes) => {
            if (attributes.originalSize) this.graph.setNodeAttribute(node, "size", attributes.originalSize);
          });
        },

        toggleColorViz(type) {
          if (this.activeColorViz === type) {
            this.resetColors();
            this.activeColorViz = null;
            this.renderer.refresh();
            return;
          }

          this.resetColors();
          this.activeColorViz = type;

          if (type === 'louvain') {
            if (!graphologyLibrary.communitiesLouvain) return alert("Louvain library not loaded.");
            const communities = graphologyLibrary.communitiesLouvain(this.graph);
            const colors = ["#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231", "#911eb4", "#46f0f0", "#f032e6", "#bcf60c", "#fabebe", "#008080", "#e6beff", "#9a6324", "#fffac8", "#800000", "#aaffc3", "#808000", "#ffd8b1", "#000075", "#808080", "#ffffff", "#000000"];
            this.graph.forEachNode((node) => {
              this.graph.setNodeAttribute(node, "color", colors[communities[node] % colors.length]);
            });
          } else if (type === 'betweenness') {
            if (!graphologyLibrary.metrics) return alert("Metrics library not loaded.");
            const scores = graphologyLibrary.metrics.centrality.betweenness(this.graph);
            const minScore = Math.min(...Object.values(scores));
            const maxScore = Math.max(...Object.values(scores));
            this.graph.forEachNode((node) => {
              const normalized = (scores[node] - minScore) / (maxScore - minScore);
              const r = 255;
              const g = Math.floor(255 * (1 - normalized * 0.8));
              const b = Math.floor(255 * (1 - normalized));
              this.graph.setNodeAttribute(node, "color", `rgb(${r}, ${g}, ${b})`);
            });
          } else if (type === 'components') {
            if (!graphologyLibrary.components) return alert("Components library not loaded.");
            const componentArrays = graphologyLibrary.components.connectedComponents(this.graph);
            let largestComponent = [];
            componentArrays.forEach(comp => {
              if (comp.length > largestComponent.length) largestComponent = comp;
            });
            const largestComponentSet = new Set(largestComponent);
            this.graph.forEachNode((node) => {
              this.graph.setNodeAttribute(node, "color", largestComponentSet.has(node) ? "#3cb44b" : "#cccccc");
            });
          }
          this.renderer.refresh();
        },

        toggleSizeViz(type) {
          if (this.activeSizeViz === type) {
            this.resetSizes();
            this.activeSizeViz = null;
            this.renderer.refresh();
            return;
          }

          this.resetSizes();
          this.activeSizeViz = type;

          if (!graphologyLibrary.metrics) return alert("Metrics library not loaded.");

          if (type === 'pagerank') {
            const scores = graphologyLibrary.metrics.centrality.pagerank(this.graph);
            const minScore = Math.min(...Object.values(scores));
            const maxScore = Math.max(...Object.values(scores));
            this.graph.forEachNode((node) => {
              this.graph.setNodeAttribute(node, "size", 3 + ((scores[node] - minScore) / (maxScore - minScore)) * 27);
            });
          } else if (type === 'degree') {
            const scores = graphologyLibrary.metrics.centrality.degree(this.graph);
            const minScore = Math.min(...Object.values(scores));
            const maxScore = Math.max(...Object.values(scores));
            this.graph.forEachNode((node) => {
              this.graph.setNodeAttribute(node, "size", 4 + ((scores[node] - minScore) / (maxScore - minScore)) * 21);
            });
          }
          this.renderer.refresh();
        },

        runLayout(layoutName) {
          this.layout = layoutName;
          const lib = window.graphologyLibrary;
          if (!lib) return;

          if (layoutName === 'forceatlas2') {
            if (lib.layoutForceAtlas2) {
              lib.layoutForceAtlas2.assign(this.graph, { iterations: 50, settings: { gravity: 1 } });
            }
          } else if (layoutName === 'circular') {
            if (lib.layout && lib.layout.circular) lib.layout.circular.assign(this.graph);
          } else if (layoutName === 'random') {
            if (lib.layout && lib.layout.random) lib.layout.random.assign(this.graph);
          } else if (layoutName === 'noverlap') {
            if (lib.layoutNoverlap) lib.layoutNoverlap.assign(this.graph);
          }

          if (this.renderer) {
            this.renderer.refresh();
            this.renderer.getCamera().animatedReset();
          }
        },

        toggleStats() {
          this.showStats = !this.showStats;
          if (this.showStats) {
            this.stats.nodes = this.graph.order;
            this.stats.edges = this.graph.size;
            this.stats.density = graphologyLibrary.metrics.graph.density(this.graph).toFixed(4);
            this.stats.avgDegree = ((2 * this.stats.edges) / this.stats.nodes).toFixed(2);
          }
        }
      }));
    });
  </script>
</body>

</html>